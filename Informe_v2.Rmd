---
title: "Aplicacion de vacunas COVID19 en Argentina - NOMIVAC: 2020-2023"
author: "Lautaro Felipe Skubaletzky"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    collapsed: true
    number_sections: true
    code_download: true
    css: hoja_estilo_tpfinal.css
    code_folding: hide 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Cargar los paquetes necesarios acá

library(rmarkdown)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)
library(tidyverse)
library(stringr)
library(lubridate)
#source("scripts/prueba_knit.R")
#source("scripts/function_grafico_estandar.R") ## NO LA PUDE HACER ANDAR
#source("scripts/function_obtener-estadisticos.R") ## NO LA PUDE HACER ANDAR
#source("scripts/function_obtener-estadisticos2.R") ## NO LA PUDE HACER ANDAR
#library(ggwordcloud)
#library(janitor)

```

# Introducción al uso de datos de la base NOMIVAC.

## Importar datos -> Muestra
Se importan los datos en un dataframe de nombre `data`. Se limita la cantidad máxima de filas a importar en la variable `mi_muestra_registros`.
```{r importa_muestra, echo=TRUE}
rm(list = ls())
set.seed(8)

# Defino mi sample registros
mi_muestra_registros <- 100000

# Data filepath
file_path <- "datos/datos_nomivac_covid19.csv"

#data <- read_csv(file_path, n_max = 10000, show_col_types = FALSE, col_select = c(id_persona_dw, fecha_aplicacion)) ## queria hacer un join luego de obtener un recorte por ultima fecha y sample.

# Import / read data
data_registro <- read_csv(file_path, n_max = mi_muestra_registros, show_col_types = FALSE)
obs_filas <- nrow(data_registro)
print(paste("Reporte parcial: Se cargan:", obs_filas, "sobservaciones."))
#Reporte parcial: Se cargan `r nrow(data)` observaciones. 

rm(obs_filas, file_path, mi_muestra_registros)
```
```{r aproximar_reg_unicos, eval=FALSE, include=FALSE}
data_registro %>% 
  group_by(id_persona_dw, fecha_aplicacion) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))

data_registro %>% 
  group_by(id_persona_dw, fecha_aplicacion) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  filter(n == 1)

data_registro %>% 
  group_by(id_persona_dw, fecha_aplicacion) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  filter(n != 1)

```

### Muestra -> Sample
Se realiza un **sample** de la muestra de datos importada al environment para reducir el tiempo computacional del procesamiento del informe. `mi_sample_registros`
```{r muestra_sample}
# Defino mi sample registros
mi_sample_registros <- 10000

# Mi sample persona es la muestra de personas que se extrae. Esto va implicar que estas son las personas que tendran inclusion en el analisis y que son quienes daran valores a las tablas, graficos, etc. Adicionalmente estas personas y sus registros de vacunacion seran incluidos en los analisis temporales de la ultima parte.
data_registro <- data_registro[sample(1:nrow(data_registro), mi_sample_registros, replace = TRUE), 1:18]
rm(mi_sample_registros)
```

#### Muestra -> Sample -> Registros únicos por cada persona (max(fecha))
Sobre la muestra aleatoria obtenida se seleccionan los **últimos registros** de vacunacion de cada persona. Se obtiene así una *"foto"* estática de esas personas en el momento mas actualizado. `data_persona`
```{r muestra_sample_persona}
data_persona <- data_registro %>% 
  group_by(id_persona_dw) %>% 
  filter(fecha_aplicacion == max(fecha_aplicacion))

#data_persona <- data_persona[,]
```

## Registros múltiples 
A continuacion se realizó un join entre la `data_persona` y `data_registro`, y como resultado se obtiene un mensaje de **many to many**. Se esperaba que fuera una base de **one to many** al obtener para la base personas el último registro de vacunación dado por la `fecha_aplicacion`. El resultado motivó a indagar más alcanzando la conclusión que la base tiene algunos errores o duplicados que se quitan a continuación. Abajo una posible solución de quitarlos de análisis.
```{r descubrimiento_repetidos}
# se descubrio que varias personas tiene multiples registros en la misma fecha. Habria que inspeccionar mas detalles sobre esas personas y esas fechas de aplicacion en las que coinciden varios registros.

# data_persona = # 9804 total de registros "personas" -> pero no porque hay registros multiples dentro de la misma fecha: `max(fecha_aplicacion)`.

# data_persona: # 9296 entre unicos y multiples
data_persona %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>%
  arrange(desc(n))

# personas con multiples registros en su `max(fecha_aplicacion)` -> a esta altura seria prudente cruzar toda la base no solamente con la fecha maxima de aplicacion sino toda group_by(id_persona_dw, fecha_aplicacion)

# data_persona_multiple: 491 registros de personas con multiples.
data_persona_multiple <- data_persona %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>%
  arrange(desc(n)) %>% 
  filter(n != 1) %>% 
  select(id_persona_dw)

# data_persona_unica: 8805 registros de personas con unicas.
data_persona_unica <- data_persona %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>%
  arrange(desc(n)) %>% 
  filter(n == 1) %>% 
  select(id_persona_dw)


```
## Join de `data_persona_unica` & `data_registro` 
Union de `data_persona` con `data_registro` de esas personas y solamente de esas personas.
```{r prueba_right_join}

# Primera base de datos con personas (sin repetirse)
data_persona_unica %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) ## chequeado que son `id_persona_dw` unicas

# Segunda base de datos con todos los registros
# data_registro

# Realizar el join uno a muchos
data_join <- inner_join(data_persona_unica, data_registro, by = "id_persona_dw")


# compruebo que los valores de la lista de `id_persona` de `data_persona_multiple` no se encuentren comprendidos en los valores de la lista de `id_persona` de `data_join`. La que de ahora en adelante será nuestra base de registros multiples de aquella otra base de personas unicas.
vector_logico <- data_persona_multiple$id_persona_dw %in% data_join$id_persona_dw
# Comprobar si hay al menos un TRUE
existe_true <- any(vector_logico)
if (existe_true) {
  print("El vector contiene al menos un TRUE, entonces la lista de registros unicos aun tiene registros multiples.")
} else {
  print("El vector no contiene ningún TRUE, entonces la lista de registros unicos es cierta.")
}

# Genero la base personas unicas final:
data_per <- data_join %>% 
  group_by(id_persona_dw) %>% 
  filter(fecha_aplicacion == max(fecha_aplicacion))

# Genero la base registros de personas unicas final
assign("data_reg", data_join, envir = .GlobalEnv)

data_reg %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))

data_per %>% 
  group_by(id_persona_dw) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n))


# elimino los demas df creados para comprobacion y busqueda de registros unicos y multiples.
rm(data_join, data_registro, data_persona, data_persona_multiple, data_persona_unica, vector_logico, existe_true)

```

Me gustaría importar los datos de todas las personas, solamente variable `id_persona_dw`, para no sobrecargar de datos la memoria de la pc. Luego armar una base de registros `id_persona_dw` unicos de 5000 observaciones y luego alli hacer un join para todas esas personas ID traer toda la informacion de sus vacunaciones. La dificultad de realizar este paso es que no se permite hacer joins_ con bases no cargadas al environment de RSTUDIO.
```{r prueba_merge_toda_variable_toda_base_out_environment}
# file_path <- "datos/datos_nomivac_covid19.csv"
# base_completa <- read_csv(file_path)[1:10,18:18]
# base_completa <- read_csv(file_path, col_select = c(id_persona_dw), n_max = 10, show_col_types = FALSE)
# left_join(data, "datos/datos_nomivac_covid19.csv", by = id_persona_dw)
```

## Exploración de los datos

:::{.alert .alert-info}

Esta sección contiene una breve descripcion de los datos cargados.

* Estructura de los datos
  * Intervalo de fechas del registro
  * Rango y magnitud de la base

* Descripcion de variables de interés
  * Dominio de las variables (valores únicos)
  * Normalizacion de valores

:::

### Estructura de los datos

####  Intervalo de fechas del registro (primero y último del recorte)
Quiero saber entre que fechas dispongo de informacion de registros de vacunación.
```{r fechas_intervalo_no_funca_formatos}
fecha_0 <- summarise(data_reg, min(fecha_aplicacion))
fecha_T <- summarise(data_reg, max(fecha_aplicacion))

#fecha_0_st <- paste0(year(fecha_0),"-" , month(fecha_0),"-", day(fecha_0))
#fecha_T_st <- paste0(year(fecha_T),"-" , month(fecha_T),"-", day(fecha_T))

#fecha_0_formateada <- format(fecha_0, "%Y-%m-%d")
#fecha_T_formateada <- format(fecha_T, "%Y-%m-%d")

print(paste0("la primer fecha disponible es del ", fecha_0, " y la ultima fecha de actualizacion es del ", fecha_T))

#La primer observacion se registró el **`r fecha_0`** y la última se registró el **`r fecha_T`**.
rm(fecha_0, fecha_T)
```

#### Rango y magnitud de la base (cantidad de observaciones y variables)
Se presentan las dimensiones de la base que sirve de registros.
```{r rango_datos}
obs_filas <- nrow(data_reg) # cantidad de observaciones (filas)
obs_cols <- ncol(data_reg) # cantidad de variables (columnas)
obs_valores = obs_filas * obs_cols # cantidad de datos (celdas)
dim(data_reg)

print(paste0("Los datos se estructuran en : ", obs_filas, " observaciones (filas) y ", obs_cols, " variables (columnas). Tenemos un total de ", obs_valores, " valores o celdas con datos."))

#Los datos se estructuran en **`r obs_filas`** observaciones (filas) y **`r obs_cols`** variables (columnas). Tenemos un total de **`r obs_valores`** valores o celdas con datos.

rm(obs_filas, obs_cols, obs_valores)
```

Cantidad de filas_observaciones (n): `r nrow(data)`

Cantidad de columnas_variables (m): `r ncol(data)`

Dimensiones, n | m: `r dim(data)`

Cantidad de celdas_valores (nxm): `r nrow(data)*ncol(data)`

### Descripción de variables de interés
Presentacion de las variables, a título informativo estos son los nombres. A continuación se seleccionan algunas variables para brindar mayores detalles de las mismas.
```{r colnames}
colnames(data_per)
```
Estas son todas las variables disponibles.

#### Dominio de las variables (valores únicos)
Se presentan a continuación los valores posibles que registran algunas de las variables, algo a lo que también haremos referencia como su dominio.
```{r summary_data_levels_factor, eval=TRUE, echo=TRUE, include=TRUE, paged.print=FALSE}

varlist <- c("sexo","grupo_etario","condicion_aplicacion","vacuna", "nombre_dosis_generica", "orden_dosis")
for (vardin in varlist){
  var_output <- data_reg[[vardin]]
  print(levels(factor(var_output)))
  #distinct(data, var_output)
}

#summary(data) # comento summary porque al no tratarse de una base muy numerica no me sirve de mucho este resumen.

#rm(fecha_0, fecha_T, obs_cols, obs_filas, obs_valores, file_path)
rm(var_output, varlist, vardin)

```
Breve descripción del tipo de datos disponibles en NOMIVAC. La gran mayoría son character, excepcion de fecha y orden dosis, así como  variables id_codigos asociadas a otras descripcion_codigos.

#### Adecuación de valores (edición, agrupación y homogeneización)
En el siguiente archivo `scripts/normalizacion-variables-valores.R` se renombran variables, se remplazan valores de variables y se agrupan valores.
```{r normalizacion_valores, eval=TRUE, echo=TRUE, include=TRUE, paged.print=FALSE}
source("scripts/normalizacion-variables-valores.R", local = TRUE, echo = TRUE)
```

## Generación de tablas y gráficos exploratorios de variables de interés

:::{.alert .alert-info}

Esta sección contiene visualizaciones tabulares y gráficas estandarizadas y **estáticas** para variables de interés. 

Todos los resultados que se presentan en esta seccion hacen referencia a una *foto* en el tiempo. 

Es decir, las tablas y gráficos corresponden a un estado de situación en un momento determinado.

Mas adelante, en la próxima sección, se realizan análisis **dinámicos** de la evolución temporal de los datos y estadísticas afínes.

* Tablas estadísticas
  * Agrupamiento de individuos `id_persona`
  * Filtrado del último registro del individuo por fecha `fecha_aplicacion`
  * Agrupamiento por variable de interés `vardin`
  * Valores mínimos, medios y máximos de `varstat`
  * Población (n_abs): cantidad de miembros que componen el grupo (`vardin`)
  * Cantidad de registros disponibles acumulados por grupo (mean_i * N_i) 
  * Población relativa (n_rel): participación del grupo sobre el total de observaciones.
  
* Gráficos 
  * Barras
  * Líneas
  * Puntos
  * Boxplots
  
:::

### Loop estadísticos descriptivos de variables de interes

Obtengo algunos df sobre las cantidades y participación de la población objetivo de la vacunación desde diferentes perspectivas como son el `sexo`, `grupo_etario`, `condicion_aplicacion` y otras. Las observaciones anteriores de personas son filtradas por la variable `fecha_aplicacion` para conservar en análisis unicamente un registro, el mas actualizado por sujeto.

```{r ls_genvar_estdesc_estdisticas_loop, eval=TRUE, include=TRUE}

# Seleccion de variables para armado de tablas de estadisticos descriptivos:
varlist <- c("sexo", "grupo_etario", "condicion_aplicacion", "vacuna", "nombre_dosis_generica", "lote_vacuna", "jurisdiccion_aplicacion", "jurisdiccion_residencia", "depto_aplicacion", "depto_residencia")

source("scripts/loop_estadisticos_descriptivos.R")

#ls_genvar_estdesc
```
Se realizó un loop para obtener estadisticas de cada agrupamiento segun la cantidad de dosis. Como se puede observar la suma de la variable `total_dosis` excede por bastante la cantidad de registros importados, esto es así, ya que no se importó toda la base, y los registros obtenidos ya tienen historial de vacunaciones anteriores.

```{r obtener_mas_abs_mas_rel}
#varias formas de jugar con listas:
ls_genvar_texto[["sexo"]]["sexo"] ## abs
ls_genvar_texto[["sexo"]]["sexo.1"] ## rel
ls_genvar_estdesc[["sexo"]]
ls_genvar_estdesc[["sexo"]]$mean_dosis[2]
max(ls_genvar_estdesc[["sexo"]]["mean_dosis"])

```

Para copiar y pegar debajo de var_obtener_estadisticos: 
```{r mejorar_incorporar_o_eliminar}
#Esta base con fecha de corte hasta `r fecha_i` y agrupación por `r vardin`, la población `r mas_abs` recibió `r varstat` mas vacunas en valor absoluto y `r mas_rel` en promedio.
```


```{r grafico_estandar_function}
print("la funcion de graficar no funciona")
print("grafico_estandar(ls_genvar_estdesc$condicion_aplicacion, condicion_aplicacion, total_dosis)")
```


### Variable `sexo`
```{r sexo_general, include=TRUE}
#Sexo
ls_genvar_estdesc$sexo
```


```{r sexo_grafico_estandar}
ls_genvar_estdesc$sexo %>% 
  ggplot(mapping = aes(sexo, total_dosis)) +
  geom_col()
ggsave(paste0("png/grafico_estandar_","sexo", "_","total_dosis", ".png"))
```

### Variable `grupo_etario`
```{r grupo_etario_general}
ls_genvar_estdesc$grupo_etario
```


```{r grupo_etario_grafico_estandar}
ls_genvar_estdesc$grupo_etario %>% 
  ggplot(mapping = aes(grupo_etario, total_dosis)) +
  geom_col()
ggsave(paste0("png/grafico_estandar_","grupo_etario", "_","total_dosis", ".png"))
```

### Variable `condicion_aplicacion`
```{r condicion_aplicacion_general}
ls_genvar_estdesc$condicion_aplicacion
```


```{r condicion_aplicacion_grafico_estandar}
ls_genvar_estdesc$condicion_aplicacion %>% 
  ggplot(mapping = aes(condicion_aplicacion, participacion)) +
  geom_col()
ggsave(paste0("png/grafico_estandar_","condicion_aplicacion", "_","total_dosis", ".png"))
```

### Variable `jurisdiccion_aplicacion`
```{r jurisdiccion_aplicacion_general}
ls_genvar_estdesc$jurisdiccion_aplicacion
```


```{r jurisdiccion_aplicacion_grafico_estandar}
ls_genvar_estdesc$jurisdiccion_aplicacion %>% 
  ggplot(mapping = aes(participacion, jurisdiccion_aplicacion)) +
  geom_col()
ggsave(paste0("png/grafico_estandar_","jurisdiccion_aplicacion", "_","total_dosis", ".png"))
```

### Variables `max(fecha_aplicacion)` y `orden_dosis`
```{r vacunas_orden_dosis_general}
varlist <- c("orden_dosis", "fecha_aplicacion")
for (esta_variable in varlist) {
  desctabla <- data_per %>% group_by(.data[[esta_variable]]) %>% summarise(n = n()) %>% mutate(prop = n / sum(n)*100)  
  print(desctabla)
  
# almacenar en lista
ls_genvar_estdesc[[esta_variable]] <- desctabla

mas_abs <- desctabla %>% 
  filter(prop == max(prop)) %>% 
  select(.data[[esta_variable]])

textabla <- data.frame(abs = mas_abs)

# almacenar en lista
ls_genvar_texto[[esta_variable]] <- textabla

}

rm("desctabla", "textabla")
```
Se observan las frecuencias de las veces que las personas fueron vacunadas segun cantidad de dosis, y en la otra tabla se obtiene la cantidad de dosis aplicadas por fecha, para las últimas aplicaciones dadas a cada persona. 

La cantidad de dosis final mas observada es de `r max(ls_genvar_texto[["orden_dosis"]])` dosis.
La fecha en que hubo mas aplicaciones de personas que no volvieron a aplicarse mas adelante nuevas dosis es 

```{r limpiar_enviroment}
ls_genvar_texto[["fecha_aplicacion"]][1,1]
ls_genvar_texto[["fecha_aplicacion"]]
ls_genvar_texto[["orden_dosis"]][1,1]
ls_genvar_texto[["orden_dosis"]]
rm(mas_abs, mas_rel)
```

# Análisis mas detallados

## Análisis dinámicos de los datos
:::{.alert .alert.info}
En esta sección se presentan análisis dinámicos de la evolución de los datos y estadísticas en un intervalo temporal.

* Aplicaciones diarias para todo el territorio 
* Días populares para vacunarse 
* Días de descanso entre dosis (tiempo promedio)

:::

### Aplicaciones diarias para todo el territorio 

Cantidad de dosis que se aplicaron cada día.
```{r}
# Obtengo data frame con aplicaciones por fecha y extiendo con el paquete lubridate.

## tabla de aplicaciones diarias:
aplicaciones_diarias <- data_reg %>% 
  group_by(fecha_aplicacion) %>% 
  summarise(dosis = n()) %>% 
  arrange(fecha_aplicacion)

## variables tiempo con lubridate - anio mes semana dia y combinaciones. Adicionalmente para semana se especifica el formato para que no se elimine el cero delante. El cero delante ya lo deja por default para el mes.
aplicaciones_diarias <- aplicaciones_diarias %>% 
  mutate(anio = year(fecha_aplicacion),
         mes = month(fecha_aplicacion),
         semana = sprintf("%02d", week(fecha_aplicacion)),
         dia = wday(fecha_aplicacion, label = TRUE, abbr = FALSE),
         anio_mes = format(fecha_aplicacion, "%Y-%m"),
         anio_semana = paste0(anio,"-",semana),
         anio_dia = paste0(anio,"-",dia))

#Ya tengo una tabla de nombre `r aplicaciones_diarias` que me permite utilizar diferentes enfoques para analizar el fenomeno temporal de la vacunacion. Voy a realizar sumas para cada unidad de tiempo y almacenar los resultados en una lista.
```

```{r ls_t_sumdosis_loop}
# Armo una lista con agrupaciones por cantidad de aplicaciones por espacio temporal
ls_t_sumdosis = list()

sumdosis_varlist <- names(aplicaciones_diarias)[-c(1,2)]

for (unidad_tiempo in sumdosis_varlist){

ls_t_sumdosis[[unidad_tiempo]] <- aplicaciones_diarias %>% 
  group_by_at(vars(one_of({{unidad_tiempo}}))) %>% 
  select(dosis, {{unidad_tiempo}}) %>% 
  summarise(suma_dosis = sum(dosis)) %>%
  mutate(part_dosis = suma_dosis / sum(suma_dosis) * 100) %>% 
  arrange({{unidad_tiempo}})
}

#ls_t_sumdosis[["anio"]]
```

:::{.alert .alert-info}
# Analisis por días de la semana
Me gustaria saber si existe alguna tendencia en la cantidad de aplicaciones diarias dependiendo el dia de la semana que toca. Por ejemplo fines de semanas vs dias de semana. O bien, en grafico de barras de dom a lun. aplicaciones promedio u otro valor que no dependa de la magnitud por ejemplo día_i/sumatoria(aplicaciones de la semana) la cual te resulta una participacion de dom[0,1].
1. Debería asociar la fecha con el día.
1. Generar una sumatoria de aplicaciones de la semana y dividir ese día por la sumatoria de la semana. O bien, promedio historico por día.
1. Hacer un grafico boxplot para evaluar visualmente las tendencias de min/media/max de aplicaciones para cada día, por ejemplo separando en 3 periodos el total, incio de la pandemia y escases de vacunas, ASPO fuerte con mas vacunacion y flexibilizacion de ASPO o actualidad. No se armar clusters pero podria ser por ahi armar los rangos de tiempo.
:::

Gráfico de las aplicaciones diarias para todas las fechas disponibles y vacunas aplicadas segun color.
```{r lista_suma_dosis_tiempo}
# Gráficos por cantidad de dosis aplicacion_diaria.

## opcion: ver por vacuna aplicada
ggplot(data_reg, mapping = aes(x = fecha_aplicacion, fill = vacuna)) + geom_bar(stat = "count")
## opcion: ver por condicion_aplicacion
ggplot(data_reg, mapping = aes(x = fecha_aplicacion, fill = condicion_aplicacion)) + geom_bar(stat = "count")
## opcion: ver por anios
ggplot(aplicaciones_diarias, mapping = aes(x = fecha_aplicacion, dosis)) + geom_point(aes(color = as.factor(anio)))

## no funciona este apartado.
anios <- c(2021, 2022, 2023)
for (este_anio in anios) {
aplicaciones_diarias %>% 
  filter(anio == este_anio) %>% 
  ggplot(aes(x = fecha_aplicacion, dosis)) + geom_col()
}
```
El gráfico permite rápidamente visualizar los períodos de mas alta vacunación. La misma es multicausal, entre las principales explicaciones son la disponibilidad de vacunas y ejecución del plan de inmunizaciones, la confianza de la población, la subida de los casos y colapso del sistema hospitalario.

## Análisis cruzados de variables
:::{.alert .alert.info}
En esta sección se presentan análisis cruzados entre variables.

* Por jurisdicción: cuantas personas de residencia_i registran aplicaciones_i
* Por persona: que vacunas recibió
* Por persona: plataforma terminada y/o + refuerzo

:::

## Análisis hipotéticos 
:::{.alert .alert.info}
En esta sección se presentan relaciones entre variables con el fin de explorar entre los resultados anteriores cuales se corresponden con algun tipo de explicacion proveniente de fenomenos culturales y sociales.

* Jovenes y la adherencia de los esquemas (estatico)
* Retomar los dias de la semana

:::

### `sexo`

### `grupo_etario`

### `condicion_aplicacion`

### `jurisdiccion_aplicacion`

## Creo nuevas variables que me sirvan para operar con la fecha

```{r dosis_personas_sexos}

# Obtener cantidad de personas por cantidad de dosis aplicadas y por sexo:
dosis_personas <- data_reg %>% 
  group_by(id_persona) %>% 
  filter(fecha_aplicacion == max(fecha_aplicacion)) %>% 
  group_by(orden_dosis, sexo) %>% 
  summarise(pob = n()) %>% 
  arrange(desc(orden_dosis))
print(dosis_personas)

dosis_personas %>% 
  ggplot(aes(orden_dosis, pob, fill = sexo)) + 
  geom_col() +
  labs(title = paste0("Dosis_personas_por_sexo"))
ggsave(paste0("png/dosis_personas_","sexo", ".png"))

# Armar la tabla en formato wide
dosis_personas_w <- dosis_personas %>% 
  pivot_wider(names_from = sexo, 
              values_from = pob, 
              values_fill = 0)
print(dosis_personas_w)

# Armar una tabla como antes, solo para M y con prop
hombres_por_dosis <- data_reg %>% 
  group_by(id_persona) %>% 
  filter(fecha_aplicacion == max(fecha_aplicacion)) %>% 
  filter(sexo == "M") %>% 
  group_by(orden_dosis) %>% 
  summarise(M_pob = n()) %>% 
  mutate(M_nrel = M_pob/sum(M_pob) * 100,
         Freq_rel_acum_M = (cumsum(M_pob) / sum(M_pob) * 100)) %>% 
  arrange((orden_dosis))
print(hombres_por_dosis)

# Armar una tabla como antes, solo para F y con prop
mujeres_por_dosis <- data_reg %>% 
  group_by(id_persona) %>% 
  filter(fecha_aplicacion == max(fecha_aplicacion)) %>% 
  filter(sexo == "F") %>% 
  group_by(orden_dosis) %>%
  summarise(F_pob = n()) %>%
  mutate(F_nrel = F_pob/sum(F_pob) * 100,
         Freq_rel_acum_F = (cumsum(F_pob) / sum(F_pob) * 100)) %>% 
  arrange((orden_dosis)) 
print(mujeres_por_dosis)

mujeres_por_dosis %>% 
  ggplot(aes(orden_dosis, Freq_rel_acum_F)) + geom_col()

# Full outer join: combinacion externa es cuando algun codigo identificador no esta disponible en la otra base. 
# En este caso debe agregarse el parametro all = TRUE para que aquellos sin coincidencia en el merge no se eliminen.
sexojoin <- merge(hombres_por_dosis, mujeres_por_dosis, by = "orden_dosis", all = TRUE)
sexojoin <- sexojoin %>% 
  arrange((orden_dosis))

# Reemplazar los valores NA por ceros
#sexojoin <- sexojoin %>% mutate_all(~ifelse(is.na(.), 0, .))
#sexojoin <- replace_na(sexojoin, replace = 0)

print(dosis_personas)
print(dosis_personas_w)
print(hombres_por_dosis)
print(mujeres_por_dosis)
print(sexojoin)

rm(hombres_por_dosis, mujeres_por_dosis)

```
De la tabla se extrae que porcentaje de cada grupo se encuentra mas inmunizado para cada nivel de inmunizacion representada por cada una nueva dosis aplicada. x_i:"5" aplicaciones el grupo_sex1:"M" tiene un %_1:"0%" mientras que el grupo_sex2:"F" tiene un %_2:"3%". y Así... Las mujeres se aplican más que los varones.

# Hipótesis

:::{.alert .alert-info}
Finalmente, esta sección contiene al menos 3 hipótesis o preguntas que puedan ser respondidas a partir de los datos. Éstas tienen que ser más o menos interesantes y no cosas que se hayan respondido con la exploración anterior.

Traten de que sean hipótesis o preguntas que relacionen 2 o más variables. Por ejemplo, “¿Cuál es el mes con más turistas en una región?” no es una pregunta intersante, pero “Existe una relación entre la cantidad de visitas y la cantidad de hoteles en una región” es una hipótesis más jugosa que apunta a la relación entre varias variables y a un fenómeno subyacente que puede tener implicancia y aplicaciones.
:::

Debido a la disponibilidad gradual de dosis de vacunas al comienzo de la pandemia resulta necesario establecer una priorización y ordenamiento de la poblacion objetivo a inmunizar en las primeras rondas con la finalidad de salvaguardar aquellos mas susceptibles, expuestos, vulnerables o de alto riesgo. Para maximizar el cuidado general de la poblacion se cree que mayores de edad, personas con comorbilidades y personal estrategico fueron los priorizados del sistema, teniendo en cuenta que el orden de priorizacion basal es evitar la muerte seguido de evitar enfermar con gravedad.

1. Por esta razón se indagará en las etapas tempranas de vacunacion la incidencia de la poblacion objetivo sobre el total y comparar esos valores con los registrados al finalizar la emergencia mundial cuando la vacuna alcanzo la suficiencia en disponibilidad irrestricta. -> Se indagará sobre las etapas tempranas de vacunacion si las mismas fueron dirigidas a quien se esperaría como poblacion diana bajo la premisa anterior, en qué proporciones y su evolucion.

1. Como segundo criterio ordenador de la estrategia de vacunacion se priorizo las personas que habitan grandes ciudades por la poca distancia que se mantiene y en condiciones de alta densidad demografica. Se puede analizar por departamentos provinciales.

1. Se cree que la poblacion priorizada obtuvo sus dosis de forma mas frecuente que otras poblaciones. Días de descanso entre dosis que tiene en promedio cada poblacion objetivo mediante la fecha de aplicacion de cada registro para cada persona. -> Para eso se calculará la cantidad de dias promedio que pasan entre una dosis y otra. dias_prom_vac1_vac2, dias_prom_vac2_vac3... y un total para dias_prom_vac1_vac99.

1. Se comenzó a flexibilizar la ASPO (AISLAMIENTO SOCIAL PREVENTIVO Y OBLIGATORIO) desde la gran disponibilidad de vacunas a partir del 2022. -> Veremos cuando se registraron picos de vacunacion que permitieron una mayor circulacion libre e irrestricta.

1. Se desea conocer alguna relacion que pueda observarse a traves de los registros sobre jurisdiccion de residencia y de aplicacion. Posiblemente existio una migracion de poblaciones debido al ASPO que puede observarse mediante este cruce o simplemente pueda obtenerse una "foto" de como las personas se mueven de su residencia hasta la aplicacion. Mediante datos espaciales disponibles en INDEC y datos abiertos se puede medir aproximadamente el desplazamiento entre ambos puntos. 

1. Los mas jovenes registraron menor adherencia a los esquemas de vacunacion que los adultos para todo el periodo en que la disponibilidad es de vacunacion libre sin requisito de etapas. Se cree que los jovenes no confian en la nueva tecnologia de inmunizacion.

## Otras exploraciones posibles

:::{.alert .alert-info}
1. vac_inicia "vacunados con esquema iniciado"
1. vac_completa "vacunados con esquema completo"
1. group_by(sexo, grupo_etario)
1. group_by(sexo, grupo_etario, condicion_salud)
:::

```{r jurisdicciones_cruce}

#tabla cruce de migraciones residencia ~ lugar de aplicacion. A modo exploratorio.
jurisdicciones_cruce <- table(data_reg$jurisdiccion_residencia, data_reg$jurisdiccion_aplicacion)
jurisdicciones_cruce_id <- table(data_reg$jurisdiccion_residencia_id, data_reg$jurisdiccion_aplicacion_id)

#jurisdicciones_cruce
#jurisdicciones_cruce_id

rm(jurisdicciones_cruce, jurisdicciones_cruce_id)
```
Se observa que la gran mayoría de personas se aplica la vacuna en su lugar de residencia, salvo pocas excepciones. Es dificil de visualizar cuantas personas se vacunan fuera de su jurisdiccion, por ello a continuacion se presenta un gráfico.

```{r jurisdicciones_poblacion}

# Armar una tabla con la caracterizacion de la poblacion del registro respecto la cantidad de personas segun al lugar de residencia y lugar de la ultima aplicacion.

## Primero una tabla con la cantidad de residentes de cada jurisdiccion:
pob_resid <- data_reg %>% 
  group_by(jurisdiccion_residencia) %>% 
  summarise(n = n()) 
## Segundo una tabla con la cantidad de aplicaciones de cada jurisdiccion:
pob_aplic <- data_reg %>% 
  group_by(jurisdiccion_aplicacion) %>% 
  summarise(n = n()) 
## Tercero la union de ambas tablas con join_by ya que usan nombres diferentes de identificacion y sufijo porque ambos usan el mismo estadistico n.
jurisdicciones_poblacion <- 
  full_join(pob_resid, pob_aplic, join_by(jurisdiccion_residencia == jurisdiccion_aplicacion), suffix = c("_residencia", "_aplicacion")) 
## Cuarto aplico la diferencia entre residentes y vacunados.
jurisdicciones_poblacion <- jurisdicciones_poblacion %>% 
  mutate(vac_extra = n_aplicacion - n_residencia) %>% 
  arrange(jurisdiccion_residencia) %>% 
  rename(jurisdiccion = jurisdiccion_residencia)

rm(pob_resid, pob_aplic)

```

```{r jurisdicciones_poblacion_detail}
# detalle extra:

## cantidad de personas *residentes* de cada jurisdiccion que se aplican en *la misma* jurisdiccion.
jresidentes <- data_reg %>% 
  filter(jurisdiccion_residencia == jurisdiccion_aplicacion) %>% 
  group_by(jurisdiccion_residencia) %>% 
  summarise(res_fix = n()) %>% 
  arrange(jurisdiccion_residencia) %>% 
  rename(jurisdiccion = jurisdiccion_residencia)

## cantidad de personas *aplicadas* en cada jurisdiccion que residen en otra jurisdiccion.
jnoresidentes <- data_reg %>% 
  filter(jurisdiccion_residencia != jurisdiccion_aplicacion) %>% 
  group_by(jurisdiccion_aplicacion) %>% 
  summarise(nores_fix = n()) %>% 
  arrange(jurisdiccion_aplicacion) %>% 
  rename(jurisdiccion = jurisdiccion_aplicacion)

## cantidad de personas *residentes* de cada jurisdiccion que se aplican en *otra* jurisdiccion.
jno_residentes <- data_reg %>% 
  filter(jurisdiccion_residencia != jurisdiccion_aplicacion) %>% 
  group_by(jurisdiccion_residencia) %>% 
  summarise(res_nofix = n()) %>% 
  arrange(jurisdiccion_residencia) %>% 
  rename(jurisdiccion = jurisdiccion_residencia)

#vacunados por jurisdiccion:
#jresidentes ## aplicados en la jurisdiccion de residencia, FIX = vacunados
#jnoresidentes ## aplicados en esta jurisdiccion que no es la de su residencia, FIX = vacunados
#jno_residentes ## aplicados en otra jurisdiccion que no es la de residencia, noFIX = no vacunados

```


```{r jurisdicciones_poblacion_join_extent}

# extiendo el df para toda la informacion asociada a estas variables
jurisdicciones_poblacion <- full_join(jurisdicciones_poblacion, jresidentes, by = "jurisdiccion")
jurisdicciones_poblacion <- full_join(jurisdicciones_poblacion, jnoresidentes, by = "jurisdiccion")
jurisdicciones_poblacion <- full_join(jurisdicciones_poblacion, jno_residentes, by = "jurisdiccion")

# libero espacio
rm(jresidentes, jnoresidentes, jno_residentes)

# reordeno, mejor lectura
col_order <- c("jurisdiccion", "n_residencia", "res_fix", "res_nofix", "n_aplicacion", "nores_fix", "vac_extra") 
jurisdicciones_poblacion <- jurisdicciones_poblacion %>% 
  select(col_order)
# alternativa de reorden
#jurisdicciones_poblacion <- jurisdicciones_poblacion[, col_order]

```


```{r}

# aplicaciones segun residencia de cada jurisdiccion.
ggplot(jurisdicciones_poblacion, aes(n_aplicacion, jurisdiccion)) + 
  geom_col(aes(res_fix, jurisdiccion, color = "blue")) + 
  geom_col(aes(nores_fix, jurisdiccion, color = "green"))
  
data_reg %>% 
  group_by(jurisdiccion_aplicacion, jurisdiccion_residencia) %>% 
  summarise(n = n()) %>% 
  arrange(desc(n)) %>% 
  ggplot(aes(n, jurisdiccion_aplicacion, fill = jurisdiccion_residencia)) + geom_col()

ggsave(paste0("png/jurisdicciones_","residencia_v_aplicacion1" ,".png"))


```
se puede observar que residentes de la provincia de Buenos Aires se aplicaron en otras jurisdcciones mas que otros ciudadanos.

Parece interesante, contrastar esta fuga de bonaerenses contra, cuantas otras personas se fugan de su jurisdiccion y donde tuvieron acogida.
```{r jurisdiccion_distribucion_residentes, message=FALSE}
data_reg %>% 
  group_by(jurisdiccion_residencia, jurisdiccion_aplicacion) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n) * 100) %>% 
  arrange(jurisdiccion_residencia) %>% 
  ggplot(aes(jurisdiccion_residencia, jurisdiccion_aplicacion, size = n)) + 
  geom_point(aes(color = jurisdiccion_residencia))
# Guardo
ggsave(paste0("png/jurisdicciones_","residencia_v_aplicacion2" ,".png"))
```


```{r grupo_etario_jovenes}
jovenes <- data_reg %>%
  mutate(grupo_etario_proxy = substr(grupo_etario, nchar(grupo_etario) - 2, nchar(grupo_etario)), 
         jovenes = ifelse(grupo_etario_proxy < 30, "joven", "adulto")) %>% 
  select(grupo_etario, grupo_etario_proxy, jovenes)

#table(data$sexo, data$grupo_etario)

#condicion_sexo <- table(data$condicion_aplicacion, data$grupo_etario)
#condicion_sexo <- round(prop.table(condicion_sexo) * 100, 2)

```
